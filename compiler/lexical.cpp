#include <iostream>
#include <fstream>
#include <vector>
#include "bintree.cpp" //неверное дерево
#include <exception>

/*Задачи:
1. Написать дерево программы, оно должно быть шаблонным, чтобы была возможность вычислять внутри него
2. Написать дерево вычислений, оно должно быть шаблонным, так как у нас не один тип
3. Написать парсер чтобы разложить термы и правила
4. Написать лексический анализатор, который будет использовать все описаннное выше, описание работы в комментарии ниже
*/

/*Операторы:
set(=), ;, if T then O else O1, :L, 
Терминалы:
char, double(int, long, double, float)
Не терминалы:
char, double(int, long, double, float), пользовательские типы
*/

int main(int argc, char* argv[]){
    if(argc == 1){
        std::cout << "No input files" << std::endl;
        return 0;
    }
    //Вопрос: А что мы будем делать, если в мэйне будет вызов другой функции?
    //Ответ: В данном случае мы указываем как область видимости мэйн

    //Вопрос: Как мы будем проверять соответствие областей видимости?
    //Ответ: В анализаторе мы будем искать скобки, если область не закрыта, выбрасываем исключение, отрабатываем его и выходим из выполнения

    /*для начала надо распарсить код на дерево выполнения
    использовать будем обратную польскую запись, чтобы было удобнее парсить
    тобешь, запись 2 + 3 == +23 
    в дереве это будет выглядеть
        +
       / \
      2   3
    *надо придумать как эффективно парсить большие значения
    *надо придумать как работать с циклами
    подпрограммы будем воспринимать просто как обл.видимости и ограничение на выводимость типа

    у каждой ноды будет несколько параметров помимо значения: //эти значения будет создавать парсер
    //так как он будет ответственнен за токенизацию, так что повесим на него еще некоторые задачи

    бул на инициализацию терма
    определение типа(чар или дабл, так как оптимизации, хуе мое)
    собственный айди с помощью которого мы сможем определять область видимости
    *нужна хорошая хэш функция, чтобы можно было без коллизий использовать этот трюк
    область видимости самого идентификатора, т.е к какой области он сейчас относится
    выделим спец области видимости:
    0 - глобальная в файле и вне файла
    -1 - глобальная в файле, но вне файла не видно, тобешь всякие static в глобале
    1 - константный айди мэйна
    * если в файле нету мэйн функции, ну например там .h
    то используем хэш функцию, которой скармливаем текущее время, берем его из либы ctime

    мы не будем проверять на наличие функций из вне файла, этим займется линковщик
    наша задача проверить все ли типы выводимы и правильно ли работает лексика языка

    пример на данный момент:
    #include <iostream> //пропускаем
    #define ... //принципиально не обрабатываем, мы на С пишем или на С++
    \n //нам все равно на спец. символы, надо будет написать нормальный парсер
    int main(){
    //проверили по спец. описаниям, это main, поэтому значения нету
    //тип - дабл, тобешь вернет только дабл
    //айди - 1
    //обл. видимости - -1 //зачем мейну смотреть вне файла, на это есть другие функции
        int a = 5;
        //сначала читаем слева направо
        //тип - дабл
        //создана переменная a, записываем в список активных переменных, думаю можно юзать вектор типа std::string
        //видим =, значит дальше будет написано значение, значение = 5
        //айди - 2, например
        //видимость - 1
        int b = 6;
        //тип - дабл
        //создана переменная b, записываем в список активных
        //значение = 6
        //айди - 3
        //видимость - 1
        int c;
        //тип - дабл
        //создана переменная c, записываем в список активных
        //значение = нету, значит переключаем проверку в фолсе
        //айди - 4
        //видимость - 1
        c = b + a;
        //смотрим, какую то переменную хотят вызвать
        //проверяем существует ли она, да она существует, идем дальше
        //видим знак =, значит в нее хотят присвоить значение
        //начинаем строить обратную польскую запись
        //идем слева направо, ищем скобки или знаки умножения/деления
        //знаки не обнаружены
        //видем знак сложения, ставим его в корень дерева вычислений
        //влево ставим b
        //вправо ставим a
        //проверяем на совпадение типов или на возможность преобразования
        //все ок
        return 0;
    }
    */

    //BinTree whole();
    return 0;
}